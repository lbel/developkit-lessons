---
title: "New features in C++14 for LHCb Physists"
teaching: 20
exercises: 0
questions:
- "What can I use from the improvements C++ in 2014?"
objectives:
- "Learn a few of the most useful tools in C++14."
keypoints:
- "Learn about C++14"
---


Unlike C++11, this is a minor release, focused mostly on improvements on top of C++11 changes, with very little that one could call "new". C++14 feels a little more natural than C++11 by exanding the usage of features and implementing common sense additions.

The biggest issue with C++14 is the GNU compiler; full C++15 support was released in version 5.0, but due to some binary changes, many projects, including SL6 and Ubuntu, chose to delay moving from version 4.9. This is finally a smaller issue with some fixes in 6.0, but it will take a while for that version to become commonly used. By run 3, hopefully C++14 and even C++17 will be completely available.

Also, while C++11 is available in ROOT 6, C++14 requies a flag and compatible compiler, so C++14 features are often unavailable.

### Auto

Types are better in C++14, with `auto` working a little better. You can now write a function returning `auto` and it will deduce the return type from the return statements instead of having to use the pecular trailing return type syntax and `decltype`.

A related improvement is with lambdas; they now support auto for parameters; this allows a template lambda functions (called generic lambdas).

### Constexpr

This expression has gained quite a bit in C++14; you can now use `if`, `switch`, and loops inside a constexpr. A bit more of the standard library now includes constexpr, as well, such as `std::array`. Most of the algorithms do not have constexpr still, requiring a third party library, sadly.

A related change is the addition of variable templates. You can now define a variable with template specializations; for example, you could define pi to provide a double and a string representation all in one variable, depending on how it is used. This could also be used to define a constant variable without being tied to a library.


### Smaller changes

The standard library received a few improvements, as well. The C++ literals syntax is finally supported by the standard library. You can now write:

```cpp
using namespace std::string_literals;
auto my_string = "This is a std::string"s;
```

Other standard library types have literals support for units now too, too, such as the chrono library. You can write

```cpp
using namespace std::literals::chrono_literals;
auto duration = 1h + 2m + 3s + 4ms + 5us + 6ns;
```

and you get a duration with those times. Complex numbers also gained a set of literals, as well.

Digit seperators, using single quotes, can make large numbers more readable. They are ignored by the compiler and are only visual aids. Binary literals are now available, using a `0b` prefix.

A few other resources:

* [Dr. Dobbs](http://www.drdobbs.com/cpp/the-c14-standard-what-you-need-to-know/240169034)
* [InfoQ](https://www.infoq.com/news/2014/08/cpp14-here-features)
