---
title: "New features in C++11 for LHCb Physicists"
teaching: 20
exercises: 0
questions:
- "What can I use from the improvements C++ in 2011?"
objectives:
- "Learn a few of the most useful tools in C++11."
keypoints:
- "Learn about C++11"
---

C++11 was the largest change ever made to C++; and due to the changed release schedule, probably will remain the largest single change. It is a well thought out, mostly backward-compatible change that can completely change the way you write code in C++. It is best thought of as almost a new language, a sort of (C++)++ language. There are too many changes to list here, and there are excellent resources available, so this is meant to just give you a taste of some of the most useful changes.

Many of the features work best together, or are related. There already are great resources for learning about C++11 (listed at the bottom of this lesson), and C++11 is already in use in current LHCb software. Therefore, the remainder of this lesson will cover a few of the common idioms in C++11 that a programmer experienced with the older C++ might not immediately think of.


## Types

Typing in C++11 is much simpler. If the type is deductible, auto allows you to avoid writing it out. A few examples of uses of auto:

```cpp
// Avoiding double writing on pointers
auto pointer = new SomeNamespace::MyLongType(arg1, arg2);

// Does anyone know the type of an iterator? It's ugly!
auto iterator = some_vector.begin();

// This is useful for prototyping, but probably should be explictly typed in real code to help coders
auto type = function_returns_something();

// Worst use of auto; don't do this
auto a = 1;
```

ROOT macros have a syntax that precedes auto; you can simply assign (`x = Something();`) and if `x` does not already exist, it does the equivalent of `auto x = Something();`. This has the drawback that it is not valid C++ code, but unfortunately is still useful in a RootBook, where you may want to rerun a cell.

The `NULL` keyword, which is equivalent to 0, causes typing issues. A new `nullptr` keyword was added, and is not equivalent to zero. This is significantly better type-safety, and should be used instead of `NULL`.

The definitions of `const` and `mutable` changed a little; [see this video](https://channel9.msdn.com/posts/C-and-Beyond-2012-Herb-Sutter-You-dont-know-blank-and-blank). In short: const actually means bit-wise constant or thread-safe; mutable means the object is already thread-safe (atomics, mutexs, some queues). This is probably what you thought they meant (but didn't) in C++98.

## Containers and iterators

While iterators existed in previous versions, using them is now part of the language, with the iterating for statement (for each). It allows a unintuitive iteration loop to be written more cleanly and compactly. Compare the following two methods of setting the values of a vector to zero:

```cpp
for(vector<double>::iterator iter = vector.begin(); iter != vector.end(); ++iter)
    *value = 0.0;

for(auto &value : vector)
    value = 0.0;
```

To make something iterable, you should define a `begin` and `end` method or function. There are several options, as well. Adding an `&` will give you a reference, to save memory copies and to allow mutation of the original iterable. Adding `const &` avoids the copy but ensures that you don't change the original iterable.

A related improvement is the addition of container constructors. Which means you can *finally* do this:

```cpp
std::vector<int> values = {1,2,3,4,5,6};
```

C++ also has a variety of different initializers; C++11 added a uniform initializer syntax, so it has even more different initializers. The benefit is that it works in more cases to initialize a value, where the other syntax choices can cause issues. Due to the addition of initialiser lists, though, this can be confusing. What does the following statement produce, a list of 42 integers, or one integer with the value 42?

```cpp
std::vector<int> vector{42};
```
> ## Answer 
> 
> This is the uniform initializer syntax, so this is the same as the old `std::vector<int> vector(42);` syntax, so it is a list of 42 integers. To use an initializer list, you would do:
> 
> ```cpp
std::vector<int> vector{ {42} };
```
> 
{: .solution}

## Functional programming

Functions are now easier to refer to and create. A `std::function` type is useful, but usually will be hidden with `auto` unless you are crafting a function to take functions as arguments. The lambda function allows an inline function definition, with some perks. The syntax is `[](){}`, which looks like a normal function definition with the function name and type replaced by the square brackets. For example:

```cpp
auto square = [](double x){return x*x;};
double squared_five = square(5.0);
```

The lambda function gets interesting when you add something to the square brackets; this is called "capture" and allows you to capture the surrounding variables. For example:

```cpp
int i = 0;
auto counter = [&i](){return i++;};
counter(); // returns 0
counter(); // returns 1
```

You can capture by value, by reference, etc. If you use `[=]` or `[&]`, the lambda function will automatically capture (by value or reference, respectively) any variables mentioned inside the function. Note that if you do use capture, you will lose the ability to convert to a old-style C function pointer.


## Class improvements

Default values for members can be declared in the definition now (as I'm sure you've tried to do in older C++ at least once). You can also call a previous constructor in the initializer list (delegating constructors).


## Compile time improvements

The slow removal of the ugly, error-prone macro programming has started in C++11, with `constexpr`. A function or class with this modifier (and lots of restrictions as to what it can contain) can be used by the compiler at compile time to produce a result in your compiled code.

The move operation was added, as well. This allows moving a value through a special `std::move`, and also can be invoked by the compiler automatically if you return a value from a function. This reduces the need to return pointers from functions.

## Std library improvements

The powerful `std::shared_ptr` and `std::unique_ptr` remove most of the reasons to fear pointers, though they don't work that well with toolkits like ROOT that try to do their own memory management. A chrono library was added for consistent timekeeping on all platforms. A threading library provides tools that work with the new functional tools and makes threading easy, and also a mutex and atomic library. A regular expression library was added. More algorithms were added, and several
container libraries. A sized integer library was *finally* added with `stdint.h` (a benefit of being based on C99).

## Variadic templates

Variadic templates allow a function or constructor to take an unlimited number of arguments of any type. This allows the `std::tuple` feature, Gaudi's functional algorithms, and other very powerful features. Although the implementation may seem unusual at first, especially if you are used to a scripting language like Python, the implementation allows the parameter expansion to happen at compile time, meaning there is no runtime penalty for using variadic templates.

The syntax uses the following constructs:

* **Declaring a parameter pack.** This is denoted by an ellipses to the *left* of a parameter name. The ellipses are usually placed next to the proceeding type, such as in `template<typename... Ts>` or `Ts... values`, but the meaning is the same. For a class this must be the last parameter; for a function it can occur earlier (but usually does not).
* **Expanding a paramter pack.** This is denoted by an ellipses to the *right* of a parameter pack or expression containing a parameter pack. This is often seen in the body of the functions. These are commonly used to call functions, `funct(values...)`, or perform an expression then call a function `funct(do_something(values)...)`. In the second example, `do_something` is called on each value before calling the `funct` function.
* **Counting the parameters in the parameter pack.** This is done with the `sizeof...()` function, which is a `constexpr` function that returns the number of parameters inside the parameter pack.

> ## Variadic template function example
> An example of a Python style print function:
> 
> ```cpp
void print() {
    std::cout << std::endl;
}
template<typename T, typename... Ts>
void print(T value, Ts... values) {
    std::cout << value << " ";
    print(values...);
}
```
> 
> Here, the ellipses serves the same role the first two times it is seen; it is declaring a parameter pack `values` with type `Ts`. Inside the function, the ellipses is expanding the call to `print(first value, second value, etc)`. This recursively calls itself, ending in the final empty argument form; a very common pattern for variadic templates.
{: .discussion}

> ## Note
>
> There is an old feature called variadic functions from C, which allows an unlimited number of arguments, but is not type safe. This is how the unlimited argument `printf` function is defined. This uses an ellipsis at the end of the parameter list, optionally after a comma.
{: .callout}

For more on variadic templates and what they can do, see [Cpp Reference's page on paramter packs](http://en.cppreference.com/w/cpp/language/parameter_pack).

## Other features

Tuples allow multiple return values, albeit through `std::tie`. In C++17 they are elevated to a more fundamental part of the language through new syntax.


> ## Futher reading
> 
> A few other resources:
> 
> * [Bjarne Stroustrup's document](http://www.stroustrup.com/C++11FAQ.html) - written by the creator of C++.
> * [SmartBear blog post](http://blog.smartbear.com/c-plus-plus/the-biggest-changes-in-c11-and-why-you-should-care/)
> * [ISO CPP](https://isocpp.org/wiki/faq/cpp11)
> * [Cpp Reference](http://en.cppreference.com/w/)
{: .callout}
